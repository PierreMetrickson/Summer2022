'''
Воробьёв Д., Нецветайлов А., КБ - 2. Калининград, 2022

Условия задачи:
I tried to send you an important message with RSA, however I messed up my RSA implementation really badly. Can you still recover the flag?
(If you think you're doing the right thing but getting garbage, be sure to check all possible solutions.)
'''

n = 27772857409875257529415990911214211975844307184430241451899407838750503024323367895540981606586709985980003435082116995888017731426634845808624796292507989171497629109450825818587383112280639037484593490692935998202437639626747133650990603333094513531505209954273004473567193235535061942991750932725808679249964667090723480397916715320876867803719301313440005075056481203859010490836599717523664197112053206745235908610484907715210436413015546671034478367679465233737115549451849810421017181842615880836253875862101545582922437858358265964489786463923280312860843031914516061327752183283528015684588796400861331354873
e = 16
ct = 11303174761894431146735697569489134747234975144162172162401674567273034831391936916397234068346115459134602443963604063679379285919302225719050193590179240191429612072131629779948379821039610415099784351073443218911356328815458050694493726951231241096695626477586428880220528001269746547018741237131741255022371957489462380305100634600499204435763201371188769446054925748151987175656677342779043435047048130599123081581036362712208692748034620245590448762406543804069935873123161582756799517226666835316588896306926659321054276507714414876684738121421124177324568084533020088172040422767194971217814466953837590498718

# ct = mess^16 (mod n)
# чтобы получить флаг требуется 4 раза извлечь из ct квадратный корень по модулю n

'''
Тест на квадратичный вычет:
Символ Лежандра
'''
def legendre_symbol(a, p):
    ls = pow(a, (p - 1) // 2, p)
    if ls == p - 1:
        return -1
    return ls


def showX(s): # Функция раскодирования решения
    print(s.to_bytes((s.bit_length() // 8) + 1, byteorder='big'))


try:
    '''
    Алгоритм Тонелли — Шенкса:
    Решает уравнение
        x^2 = a mod p
    и вовращает turple из двух решений или пустой
    '''
    def prime_mod_sqrt(a, p, l):
        if l == 4:
            print(showX(a))
        else:
            l += 1
            a %= p

            '''
            Тривиальные случаи 
                a == 0; p == 2
            невозможны
            '''

            # Проверка на наличие решений
            if legendre_symbol(a, p) == -1:
                print(showX(a))

            # Простейший случай
            if p % 4 == 3:
                x = pow(a, (p + 1) // 4, p)
                prime_mod_sqrt(x, n, l)
                prime_mod_sqrt(p - x, n, l)

            # Приведение p-1 к виду q * 2^s
            q, s = p - 1, 0
            while q % 2 == 0:
                s += 1
                q //= 2

            # Выбирается z которое не является кв. вычетом по модулю p
            z = 1
            while legendre_symbol(z, p) != -1:
                z += 1
            c = pow(z, q, p)

            # Поиск решения
            x = pow(a, (q + 1) // 2, p)
            t = pow(a, q, p)
            m = s
            while t != 1:
                # Находит наименьшее i такое что t^(2^i) = 1
                i, e = 0, 2
                for i in range(1, m):
                    if pow(t, e, p) == 1:
                        break
                    e *= 2

                # Подготовка к следующей  итерации
                b = pow(c, 2 ** (m - i - 1), p)
                x = (x * b) % p
                t = (t * b * b) % p
                c = (b * b) % p
                m = i

            prime_mod_sqrt(x, n, l)
            prime_mod_sqrt(p - x, n, l)

    m = 0   # считает сколько раз извлекли квадратный корень из ct
    prime_mod_sqrt(ct, n, m)
except TypeError:
    print("")